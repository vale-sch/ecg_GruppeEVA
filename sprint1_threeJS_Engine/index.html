<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <link href="./Css/index.css" rel="stylesheet" type="text/css">
    <script type="module" src="js/main.js"></script>
    <title>RTCG-WP-02P</title>

</head>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js">
</script>
<script type="text/javascript">
    $(document).ready(function () {
        console.log("Documentbereit!");
    });
</script>

<body>
    <span id="fps-counter">asd</span>
    <div id="scene-container">
    </div>
</body>

<script type="x-shader/x-vertex" id="vertexShader">
    varying vec4 vFragColor;
    varying vec2 vUV;

    void main() {
        gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position,1.);
        vFragColor = vec4(0.,0.,0.,1.);
        vUV = uv;
    }   
</script>

<script type="x-shader/x-fragment" id="fragmentShader">

    #define MAX_MARCHING_STEPS 128
    #define EPSILON 0.00001
    #define MAX_DIST 100.

    uniform float Time;

    varying vec4 vFragColor;
    varying vec2 vUV;

    
    float smin( float a, float b, float k )
    {
        float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );
        return mix( b, a, h ) - k*h*(1.0-h);
    }

    float sdSphere( vec3 p,  vec3 pos, float r)
    {
        return distance(pos,p)-r;
    }

    float map(vec3 p){
        float s1 = sdSphere(p, vec3(-0.3,0.,0.),0.5) + sin(sin(Time) * sin(Time) * 15. * p.x - Time * 2.) * sin(sin(Time) * sin(Time) * 15. * p.y + Time * 2.) * sin(sin(Time) * sin(Time) * 15. * p.z  + Time) * sin(Time) * 0.075;
        float s2 = sdSphere(p, vec3(0.3,0.,0.),0.5);
        float s3 = sdSphere(p, vec3(0.,0.,0.),0.5) + sin(sin(Time) * sin(Time) * 15. * p.x - Time * 2.) * sin(sin(Time) * sin(Time) * 15. * p.y + Time * 2.) * sin(sin(Time) * sin(Time) * 15. * p.z  + Time) * sin(Time) * 0.075;
        return s3;
        //return smin(s1,s2,0.2);
    }

    float castRay(vec3 eye, vec3 marchingDirection, float start, float end) {
        float depth = start;
        for (int i = 0; i < MAX_MARCHING_STEPS; i++) {
            float dist = map(eye + depth * marchingDirection);
            if (dist < EPSILON) {
                return depth;
            }
            depth += dist;
            if (depth >= end) {
                return end;
            }
        }
        return end;
    }

    vec3 calcNormal( in vec3 p ) // for function f(p)
    {
       const vec2 h = vec2(EPSILON,0.);
      return normalize( vec3(map(p+h.xyy) - map(p-h.xyy),
                             map(p+h.yxy) - map(p-h.yxy),
                              map(p+h.yyx) - map(p-h.yyx) ) );
    }

    vec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {
        vec2 xy = fragCoord - size / 2.0;
        float z = size.y / tan(radians(fieldOfView) / 2.0);
        return normalize(vec3(xy, -z));
    }

    void main() {
        vec3 dir = normalize(vec3(vUV * 2. - vec2(1.,1.3),-5.));//rayDirection(45.0,vec2(100.,100.),gl_FragCoord.xy);

        vec3 eye = vec3(0.,0.3,4.);

        vec3 light = vec3(0.,3.,0.);

        float dist = castRay(eye,dir,0.01,MAX_DIST);

        if (dist > MAX_DIST - EPSILON) {
            // Didn't hit anything
            gl_FragColor = vFragColor;
        return;
        }

        vec3 hitPoint = eye + dir * dist;

        vec3 lightDir = normalize(light-hitPoint);

        vec3 normal = calcNormal(hitPoint);

        float brightness = max(dot(lightDir,normal),0.);

        gl_FragColor = vec4(calcNormal(hitPoint), 1.0);
    }   
</script>

</html>